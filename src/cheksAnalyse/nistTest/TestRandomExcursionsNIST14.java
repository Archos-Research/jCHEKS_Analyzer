package cheksAnalyse.nistTest;

import com.archosResearch.jCHEKS.concept.chaoticSystem.AbstractChaoticSystem;
import java.util.ArrayList;
import static org.apache.commons.math3.special.Gamma.regularizedGammaQ;

/**
 *
 * @author Michael Roussel rousselm4@gmail.com
 */
public class TestRandomExcursionsNIST14 extends AbstractNistTest{

    public static final int BITS_NEEDED = 0; //TODO Set this value
    public static final String TABLE_NAME = "random_excursions_NIST_14";
    
    public TestRandomExcursionsNIST14(AbstractChaoticSystem chaoticSystem) throws Exception {
        super(chaoticSystem, BITS_NEEDED);
        this.type = AnalyserType.NIST_14;
    }
    
    @Override
    public void executeTest(boolean[] bits) {
        /* 
         * The variable bits is the input bits of the lenght of BITS_NEEDED generated by the chaotic system.
         * This method should change pValue attribute of the result.
         * this.pValue = result;
         * It is recommended that each sequence to be tested consist of a minimum of 1,000,000 bits (i.e., n â‰¥ 106).
         */
        int n = bits.length;
        
        double[][] pi = {{0.0000000000, 0.00000000000, 0.00000000000, 0.00000000000, 0.00000000000, 0.0000000000}, 
                        {0.5000000000, 0.25000000000, 0.12500000000, 0.06250000000, 0.03125000000, 0.0312500000},
                        {0.7500000000, 0.06250000000, 0.04687500000, 0.03515625000, 0.02636718750, 0.0791015625},
                        {0.8333333333, 0.02777777778, 0.02314814815, 0.01929012346, 0.01607510288, 0.0803755143},
                        {0.8750000000, 0.01562500000, 0.01367187500, 0.01196289063, 0.01046752930, 0.0732727051} };
        
        int[] stateX = {-4, -3, -2, -1, 1, 2, 3, 4};
        int[] sk = new int[n + 2];
        
        sk[0] = 0;
        sk[n + 1] = 0;
        
        // Compute the cumulative sums
        for (int i = 1; i < bits.length + 1; i++) {
            sk[i] = sk[i-1] + (bits[i] ? 1 : -1);
        }
        
        // Get the cycles ranges
        int J = 0;
        ArrayList<Integer> cyclesArray = new ArrayList<>();
        for (int x = 0; x < sk.length; x++) {
            if (sk[x] == 0) {
                cyclesArray.add(x);
                J++;
            }
        }
        
        // Check the constraint (number of cycles should be greater than 500)
        if (J < 500) {
            // Insufficient number of cycles to run the tests
            // TODO : Throw an error
            return;
        }
        
        // Convert the array list to an int array
        Integer[] cycles = new Integer[cyclesArray.size()];
        cycles = cyclesArray.toArray(cycles);
        
        // Create an occurence matrix and populate the values
        double[][] nu = new double[6][8];
        for (int x = 0; x < 6; x++) {
            for (int y = 0; y < 8; y++) {
                nu[x][y] = 0;
            }
        }
        
        // Calculate the occurences in each cycle
        int counter[] = new int[8];
        for (int x = 0; x <= (cycles.length - 1); x++) {
            // Initializ the counter vector
            for (int i = 0; i < 8; i++) {
                counter[i] = 0;
            }
            
            // Calculate the occurences of X in the cycle
            for (int i = cycles[x]; i < cycles[x + 1]; i++) {
                if ( (sk[i] >= 1 && sk[i] <= 4) || (sk[i] >= -4 && sk[i] <= -1) ) {
                    if ( sk[i] < 0 ) {
                        counter[sk[i] + 4]++;
                    } else {
                        counter[sk[i] + 3]++;
                    }
                }
            }
            
            // Populate the result matrix for the cycle
            for (int i = 0; i < 8; i++) {
                if ((counter[i] >= 0) && (counter[i] <= 4)) {
                    nu[counter[i]][i]++;
                } else if (counter[i] >= 5) {
                    nu[5][i]++;
                }
            }
        }

        double[] pValues = new double[18];
        
        // Calculate p-values for each possible state of X
        for (int i = 0; i < 8; i++) {
                int sum = 0;
                
                for (int k = 0; k < 6; k++) {
                    sum += Math.pow(nu[k][i] - J* pi[(int)Math.abs(stateX[i])][k], 2) / (J*pi[(int)Math.abs(stateX[i])][k]);
                }
                
                pValues[i] = regularizedGammaQ(2.5, sum/2.0);
        }
        
        // TODO : Log independant P values instead of a mean
        for (double d : pValues) {
            this.pValue += d;
        }
        
        this.pValue /= pValues.length;
    }

    @Override
    public String getTableName() {
        return TABLE_NAME;
    }
    
}
